// Generated by CoffeeScript 1.8.0
(function() {
  var exec, p, vagrant;

  exec = require('child_process').exec;

  p = require('prettyput');

  vagrant = {
    status: function(callback) {
      return exec('vagrant global-status --prune', function(err, stdout, stderr) {
        var arr, machineStatusList, parsedStatusArr, status, _i, _len;
        p.e(err);
        machineStatusList = [];
        parsedStatusArr = vagrant._machineStatusParse(stdout);
        for (_i = 0, _len = parsedStatusArr.length; _i < _len; _i++) {
          status = parsedStatusArr[_i];
          arr = vagrant._splitWithoutEmpty(status, ' ');
          machineStatusList.push({
            id: arr[0],
            name: arr[1],
            provider: arr[2],
            state: arr[3],
            directory: arr[4]
          });
        }
        return callback(machineStatusList, stderr);
      });
    },
    _machineStatusParse: function(text) {
      var machineStatusList;
      machineStatusList = text.split("\n");
      if (machineStatusList.length <= 6) {
        return [];
      } else {
        return machineStatusList.slice(2, -8);
      }
    },
    boxList: function(callback) {
      return exec('vagrant box list --machine-readable', function(err, stdout, stderr) {
        var boxes, i, splitedBoxListText, _i, _ref;
        p.e(err);
        splitedBoxListText = vagrant._splitWithoutEmpty(stdout, '\n');
        boxes = [];
        for (i = _i = 0, _ref = splitedBoxListText.length / 3; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          boxes.push({
            name: (vagrant._splitWithoutEmpty(splitedBoxListText[i * 3], ','))[2],
            provider: (vagrant._splitWithoutEmpty(splitedBoxListText[i * 3 + 1], ','))[2],
            version: (vagrant._splitWithoutEmpty(splitedBoxListText[i * 3 + 2], ','))[2]
          });
        }
        return callback(boxes, stderr);
      });
    },
    boxAdd: function(boxName, boxUrl, callback) {
      return exec('vagrant box add ' + boxName + ' ' + boxUrl, function(err, stdout, stderr) {
        p.e(err);
        return callback(stdout, stderr);
      });
    },
    boxRemove: function(boxName, callback) {
      return exec('vagrant box remove ' + boxName, function(err, stdout, stderr) {
        p.e(err);
        return callback(stdout, stderr);
      });
    },
    destroy: function(machineId, callback) {
      return exec('vagrant destroy -f ' + machineId, function(err, stdout, stderr) {
        p.e(err);
        return callback(stdout, stderr);
      });
    },
    up: function(vagrantfileDir, callback) {
      return exec('VAGRANT_CWD="' + vagrantfileDir + '" vagrant up', function(err, stdout, stderr) {
        p.e(err);
        return callback(stdout, stderr);
      });
    },
    halt: function(machineId, callback) {
      return exec('vagrant halt -f ' + machineId, function(err, stdout, stderr) {
        p.e(err);
        return callback(stdout, stderr);
      });
    },
    suspend: function(machineId, callback) {
      return exec('vagrant suspend ' + machineId, function(err, stdout, stderr) {
        p.e(err);
        return callback(stdout, stderr);
      });
    },
    resume: function(machineId, callback) {
      return exec('vagrant resume ' + machineId, function(err, stdout, stderr) {
        p.e(err);
        return callback(stdout, stderr);
      });
    },
    provision: function(machineId, callback) {
      return exec('vagrant provision ' + machineId, function(err, stdout, stderr) {
        p.e(err);
        return callback(stdout, stderr);
      });
    },
    _splitWithoutEmpty: function(text, pattern) {
      var newArray, preArray, v, _i, _len;
      preArray = text.split(pattern);
      newArray = [];
      for (_i = 0, _len = preArray.length; _i < _len; _i++) {
        v = preArray[_i];
        if (v !== void 0 && v !== "") {
          newArray.push(v);
        }
      }
      return newArray;
    }
  };

  module.exports = vagrant;

}).call(this);
